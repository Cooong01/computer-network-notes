# 2.1 应用层协议原理
## 2.1.1 网络应用程序体系结构
- 两种主流体系结构：客户-服务器体系结构（client-server architecture）和对等（P2P）体系结构
	- 客户-服务器体系结构：有一个保持打开的主机称为服务器，服务于来自许多被称为客户的主机的请求。例如，Web、FTP、Telnet。单台服务器主机满足不了请求时，配备大量主机的数据中心（data center）
	- P2P体系结构：对等方主机之间直接通信。具有自拓展性，每个对等方向其他对等方分发文件为系统增加服务能力。非集中式结构，不需要庞大的服务器基础设施和服务器带宽。
## 2.1.2进程通信
- 报文（message），进程（process）
- 客户和服务器进程
	- 网络应用程序由成对的进程组成，进程间通过网络互相发送报文。在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程是客户，在会话开始时等待联系的进程是服务器（包括P2P）。
- 进程与计算机网络之间的接口
	- 进程通过一个称为套接字（socket）的软件接口向网络发送报文和从网络接收报文。进程是房子，则套接字类似于进程的门。
	- 套接字是同一台主机内应用层和运输层之间的接口。套接字是建立网络应用程序的可编程接口，因此也称为应用程序和网络之间的应用程序编程接口（Application Programming Interface，API）。
	- 应用程序开发者对于运输层的控制仅限于：选择运输层协议、也许能设定几个运输层参数，如最大缓存和最大报文段长度等
- 进程寻址
	- 在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识接收进程，需要定义两种信息：主机的地址，和在目的主机中指定接收进程的标识符。
	- 在因特网中，主机由IP地址标识。除了知道报文发送目的地的主机地址之外，发送进程还碧玺指定运行在接收主机上的接收进程（接收套接字）。目的地端口号（port number）被用于这个目的。
## 2.1.3 可供应用程序使用的运输服务
- 大体从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性。
- ==可靠数据传输==：如果一个协议提供了确保数据交付服务，就认为提供了可靠数据传输（reliable datatransfer）。不可靠的数据传输可以被容容任丢失的应用（loss-tolerant application）接受。
- ==吞吐量==：运输层协议能以某种特定速率提供确保的可用吞吐量。有吞吐量要求的应用程序被称为带宽敏感的应用（bandwidth-sensitive application），比如多媒体应用。弹性应用（elastic application）能够根据当时可用的带宽来利用吞吐量。比如电子邮件，文件传输和Web传送。
- ==定时==：运输层协议能提供定时保证。比如发送方和接收方的每个比特经过套接字的时间差不超过100ms。
- ==安全性==：运输层协议提供多种安全性服务。比如，在发送主机中加密数据，接收主机解密。此外，还有数据完整性和端点鉴别服务。
## 2.1.4 因特网提供的运输服务
- ==TCP服务==：包括面向连接服务和可靠数据传输服务。此表格显示选用TCP的一些网络应用：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=79&selection=128,0,132,10|计算机网络：自顶向下方法（原书第七版）, page 79]]。
	- 面向连接的服务：在应用层数据报文开始流动之前，TCP先让客户端和服务器交换运输层控制信息。这个过程叫握手阶段。握手阶段结束后，一个TCP连接就在两个进程的套接字之间建立了。当应用程序结束报文发送时，必须拆除该连接。
	- 可靠的数据传送服务：无差错、按照适当顺序交付所有发送的数据。
	- 另外，还有拥塞控制机制。TCP会在两端之间的网络拥塞时抑制发送进程。而且TCP试图限制每个TCP连接，来达到让他们公平共享网络带宽的目的。
	- TCP和UDP都没有加密机制。因此TCP有加强版：安全套接字层（Secure Sockerts Layer，SLL）。它包含TCP能做的一切，并提供安全性服务，比如加密，数据完整性和端点鉴别。这是应用层实现的，不和TCP在一个层次上。SSL有自己的套接字API，发送进程向SSL传递明文数据，SSL加密后再发送给TCP套接字。
- ==UDP服务==：仅提供最小服务，没有握手进程，数据传送服务并不可靠，也可能乱序。没有拥塞控制机制。可以以任何数据向其下层注入数据。
- 因特网运输协议不提供的服务：吞吐量或定时保证。这需要应用程序的特殊设计。
## 2.1.5 应用层协议
- 定义了运行在不同的端系统上的应用程序进程如何相互传递报文，特别是，定义了：
	- 交换的报文类型。比如请求报文和响应报文。
	- 各种报文类型的语法。比如报文中的各个字段。
	- 字段的语义。
	- 一个进程何时以及如何发送报文，对报文进行相应的规则。
- 有些应用层协议用RFC文档定义，因此位于公共域中，比如HTTP。还有专用的应用层协议，有意不让公共域使用。
- 关于Web的解释：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=81&selection=169,0,252,0|计算机网络：自顶向下方法（原书第七版）, page 81]] 。电子邮件主要应用层协议是SMTP。
# 2.2 Web和HTTP
20世纪90年代初期，万维网（World Wide Web）登上舞台。
## 2.2.1 HTTP概况
- Web应用层协议是==超文本传输协议（HyperText Transfer Protocol，HTTP）==，它是Web的核心。HTTP由客户程序和服务器程序两个程序实现。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。
- ==Web页面（Web page）==：也叫文档，是由对象组成的。
- ==对象==：只是一个文件，诸如HTML文件、JPEG图形、Java小程序或视频片段。它们可通过URL地址寻址。
- ==HTML基本页面（base HTML file）==：多数Web页面含有一个HTML基本页面以及几个引用对象。比如，一个Web页面有HTML文本和JPEG图形，那么这个页面有6个对象。HTML基本文件通过对象的URL地址引用页面中的其他对象。每个URL由两部分组成：存放对象的服务器主机名和对象的路径名。比如，http: //www.someSchool.edu/someDepartment/pielure.gif，www.someSchool.edu就是主机名，/someDepartment/pielure.gif就是路径名。
- ==Web浏览器（Web browser）==实现了HTTP的客户端，所以浏览器和客户这两个术语经常交替使用。
- ==Web服务器（Web server）==实现了HTTP的服务器端，它用于储存Web对象。
- HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。其使用TCP作为支撑运输协议。HTTP客户首先发起一个与服务器的TCP连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问TCP。重要的是，服务器向客户发送被请求的文件，但是不存储任何关于该客户的状态信息。所以HTTP是一个无状态协议（stateless protocol）。HTTP使用客户-服务器应用程序体系结构。Web服务器总是打开的。
## 2.2.2 非持续连接和持续连接
首先，我们假设客户和服务器在相当长的时间范围内通信，其中客户发出*一系列*请求并且服务器要对每个请求进行响应。
- ==非持续连接（non-persistent connection）==：每个请求/响应对都经一个单独的TCP连接发送。
- ==持续连接（persistent connection）==：所有请求及其响应经相同的TCP连接发送。HTTP默认方式下使用持续连接，但是也能配置成使用非持续连接。
1. 采用非持续连接的HTTP的步骤：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=84&selection=88,0,295,1|计算机网络：自顶向下方法（原书第七版）, page 84]] 
	- HTTP与客户端如何解释一个Web页面毫无关系。
	- 假设传输了1个HTML基本文件和10个JPEG图形，则在这个例子里，产生11个TCP连接。
	- 值得注意的是，这10个JPEG图形既可以使用串行的TCP连接，也可以并行。可以配置浏览器来控制并行程度。并行越多，响应时间越短。
	- ==往返时间（Round-Trip Time，RTT）==：指一个短分组从客户到服务器然后再返回客户所花费的时间。
	- 缺点：第一，必须为每一个请求的对象建立和维护一个全新的连接。每个连接都要在客户和服务器中分配TCP的缓冲区和保持TCP变量，给Web服务器带来了严重的负担。第二，每个对象经受两倍RTT交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。
1. 采用持续连接的HTTP：
	- 一个或同一个服务器的多个Web页面可以在从该服务器发送给同一个客户时在单个持续的TCP连接上进行。
	- 一般，一条连接经过一定时间间隔仍然未被使用，HTTP服务器关闭该连接。
## 2.2.3 HTTP报文格式
HTTP报文有两种：请求报文和响应报文。
1. 请求报文：
	- 典型请求报文：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=85&selection=370,0,424,1|计算机网络：自顶向下方法（原书第七版）, page 85]]  ![[Pasted image 20230923233459.png]] 第一行叫做==请求行（request line）==。后继的那几行叫==首部行（header line）==。请求行包含方法字段、URL字段和HTTP版本字段。
		- 方法字段有许多不同的值，比如POST，HEAD（请求，但服务器不返回请求对象），PUT（允许用户上传对象到指定Web服务器的指定路径），DELETE（允许用户或应用程序删除Web服务器上的对象），绝大部分HTTP请求报文使用GET。版本文段是自解释的。
		- 首部行第一行指明对象所在的主机，第二行表示服务器发完被请求的对象后就关闭连接，第三行指明用户代理，即浏览器类型（服务器可以为不同用户代理发送相同对象的不同版本，不过每个版本的URL相同。）。最后一行表示想得到对象的法语版本。首部行结束之后要空行。
	- HTTP请求报文的通用格式：![[Pasted image 20230923234407.png]]  当用POST时，就会用到实体体，用来表达用户在表单字段输入的内容。但是，*用表单生成的请求报文不是必须使用POST方法*。表单经常使用GET方法，并且在表单所请求的URL里包括输入的数据。
2. HTTP响应报文
	-  典型的HTTP响应报文（对上文例子的响应）：![[Pasted image 20230923235006.png]] 包含==状态行（status line）==、==首部行（header line）==、==实体体（entity body）==。
		- 状态行有三个字段，协议版本字段、状态码和相应状态信息。
		- 首部行第二行指示服务器产生并发送该相应报文的日期和时间（服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间）。
		- 首部行第三行指示该报文的服务器是Apache Web，类似于请求报文的User-agent。
		- 首部行第四行指示对象创建或者最后修改的日期和时间。
		- 首部行第五行指示被发送对象中的字节数。
		- 首部行第六航指示实体体中的对象是HTML文本。
		- 一些常见状态码和对应的短语：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=87&selection=497,1,579,1|计算机网络：自顶向下方法（原书第七版）, page 87]] ![[Pasted image 20230923235925.png]] 
## 2.2.4 用户与服务器的交互：cookie
- HTTP服务器是无状态的，不存储用户信息。而cookie能对用户进行跟踪。cookie技术有4个组件
	- 在HTTP响应报文中的一个cookie首部行
	- 在HTTP请求报文中的一个cookie首部行
	- 在用户端系统中保留一个cookie文件，并由用户的浏览器管理
	- 位于Web站点的一个后端数据库。
	- cookie的一个例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=88&selection=450,0,564,5|计算机网络：自顶向下方法（原书第七版）, page 88]] 
- cookie能指示一个用户的唯一识别码，并指引Web后端数据库产生一个表项，包含该用户在网站的一些行为。
## 2.2.5 Web缓存
- ==Web缓存器（Web cache）==也叫==代理服务器（proxy server）==，它是能够代表初始Web服务器来满足HTTP请求的网络实体。它有自己的磁盘存储空间，并保存着最近请求过的对象的副本。
	- Web缓存器起作用的一个例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=90&selection=148,1,323,1|计算机网络：自顶向下方法（原书第七版）, page 90]] 
	- 在因特网部署Web缓存器有两个原因：
		- 首先，Web缓存器可以dada减少对客户请求的响应时间（特别是，客户端与原服务器和与Web缓存器之间的带宽差距大的时候）
		- 其次，Web缓存器能大大减少一个机构的接入链路到因特网的通信量。通过减少通信量，就不用急着增加带宽，增长成本。
		- 此外，Web缓存器能整体上大大减低因特网上的Web流量，从而改善了所有应用的性能。
		- 另外一个体现缓存器好处的例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=91&selection=373,0,391,0|计算机网络：自顶向下方法（原书第七版）, page 91]] 
	- ==内容分发网络（Content Distribution Network，CDN）==：CDN公司会在因特网上安装许多地理上分散的缓存器，使大量流量实现本地化。
## 2.2.6条件GET方法
- ==条件GET（conditional GET）==方法是HTTP协议中的一种机制，能允许缓存器证实它的对象是最新的。 使用方式：
	- 请求报文使用GET方法
	- 并且，请求报文中包含一个“If-Modified-Since:”首部行。
	- 一个例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=92&selection=285,3,516,5|计算机网络：自顶向下方法（原书第七版）, page 92]] 
# 2.3 因特网中的电子邮件
- 因特网电子邮件主要组成部分：==用户代理（user agent）==、==邮件服务器（mail server）==和==简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）== 。
	- 用户代理相当于HTTP中的浏览器，允许用户阅读、回复、转发、保存和撰写报文。微软的Outlook和Apple Mail是一个例子。
	- 邮件服务器是电子邮件体系结构的核心。每个接收方在其中某个邮件服务器上有一个邮箱（mailbox）。典型的邮件发送过程：从发送方的用户代理开始，传输到发送方的邮件服务器，在传输到接收方的邮件服务器，在这里被分发到接收方的邮箱中。当Bob要在他的邮箱中读取该报文时，这个邮箱背后的邮件服务器会鉴别Bob（也就是用用户名和密码）。如果邮件不能交付给接收方的服务器，那么发送方的服务器会在一个报文队列（message queue）中保存该报文，并在之后尝试再次发送。如果长时间失败，服务器删除报文，并以电子邮件形式告诉发送方。
	- 简单邮件传输协议（SMTP）是因特网电子邮件中的主要应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。在单次发送过程中，认为在两个服务器上都有SMTP的一部分（一个是客户端，一个是服务器端）。
## 2.3.1 SMTP
- SMTP问世时间比HTTP要长得多。但是也因此，SMTP带着一些旧时代的性能限制功能，比如所有邮件报文的体部分只采用简单的7比特ASCII，那么多媒体需要编码为ASCII才能发，收到后还需要解码。
- SMTP的基本操作：
	- 1）发送方调用用户代理，提供接收方的邮件地址，撰写报文，指示用户代理发送报文。
	- 2）用户代理把报文发给邮件服务器，在这里，报文被放在报文队列里。
	- 3）邮件服务器上的SMTP客户端发现了报文队列里的这个报文，就创建一个到接收方邮件服务器上SMTP服务器的TCP连接（25号端口，持续连接）。
	- 4）经过一些初始SMTP握手后，SMTP客户端通过这个TCP连接发送报文。
	- 5）在接收方服务器上的SMTP服务器端接收报文，放入接收方邮箱里。
	- 6）接收方调用用户代理阅读报文。
	- 一个例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=96&selection=73,1,409,1|计算机网络：自顶向下方法（原书第七版）, page 96]] 
## 2.3.2 与HTTP的对比
- 共同点：都用于一台主机向另一台主机传送文件、都使用持续连接。
- 区别：
	- HTTP是一个拉协议（pull protocol），用户用HTTP从服务器拉取信息，TCP连接是从想接收文件的服务器发起的。SMTP基本上是一个推协议（push protocol）。发送邮件服务器把文件推向接收邮件服务器，这个TCP是由要发送该文件的机器发起的。
	- SMTP要求每个报文用7比特ASCII码格式，HTTP数据不受这种限制。
	- 关于如何处理一个既包含文本又包含图形（或者其他多媒体）的文档，HTTP把每个对象封装到自己的HTTP响应报文里，SMTP把所有报文对象放在一个报文之中。
## 2.3.3 邮件报文格式
- 首部行由RFC5322定义，首部行与该报文的体用空行进行分隔。每个首部行必须包含一个From:首部行和一个To:首部行；一个首部也许包含一个Subject:首部行和其他可选的首部行。
- 一个典型的报文首部：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=97&selection=270,0,326,1|计算机网络：自顶向下方法（原书第七版）, page 97]] 
## 2.3.4 邮件访问协议
- 我们知道，SMTP是一个推协议，不能拉。所以，从发送方的用户代理一直到接收方的邮件服务器都可以使用SMTP（发送方用户代理-（SMTP）->发送方邮件服务器-（SMTP）->接收方邮件服务器），但是接收方需要在他的用户代理上拉取接收方邮件服务器里邮箱的邮件，此时引入一个特殊的邮件访问协议来解决这个问题。目前有一些流行的邮件访问协议，包括==第三版邮局协议（Post Office Protocol-Version 3，POP3）==、==因特网邮件访问协议（Internet Mail Access Protocol，IMAP）==以及==HTTP==。
### 1. POP3
- POP3是一个极为简单的邮件访问协议，因为协议非常简单，所以功能相当有限。当用户代理打开一个到邮件服务器端口110上的TCP连接后，POP3开始工作，按照三个阶段进行：
	- 特许（authorization）：用户代理发送（明文）用户名和密码来鉴别用户。有两个主要的命令：user\<user name>和pass\<password>
	- 事务处理：用户代理取回报文，同时用户代理还能对报文做删除的标记以及取消这个标记。用户代理发出一些命令，服务器对每个命令做出回答，回答可能有两种：+OK（有时后面还跟着服务器到客户的数据），被服务器用来指示前面的命令是正常的；-ERR，被服务器用来指示前面的命令出了某些差错。
	- 更新：出现在客户发了quit命令之后，目的是结束该POP3会话，这时，邮件服务器就会删除那些被标记为删除的报文。
- 另外，用户代理可以被用户配置为“下载并删除”或者“下载并保留”（此处的删除和保留指的是在服务器端的对应报文）。
- POP3不能指定在服务器端创建远程文件夹。POP3服务器不在POP3会话过程中携带状态信息。不过POP3服务器会保留一些状态信息，比如记录哪些用户报文被标记为删除了。
### 2. IMAP
- IMAP也是一个邮件访问协议，能解决POP3不能解决的创建远程服务器文件夹的问题，这样可以从任何一台机器上对所有报文进行访问。
- 报文第一次到达服务器时，与收件人邮件文件夹（INBOX）关联，收件人能把邮件移到一个新的自己创建的文件夹中，并阅读邮件，删除邮件等。IMAP还为用户提供了在远程文件夹中查询邮件的指令。IMAP服务器维护IMAP会话的用户状态信息，比如文件夹的名字以及哪些报文与哪些文件夹相关。
- 另外，IMAP允许用户代理只获取报文某些部分，比如可以只读报文首部，这样用户在低带宽的时候可以不取回邮箱中的所有邮件，比如音频或视频片段这些大邮件。
### 3. 基于Web的电子邮件
- 上世纪90年代，Hotmail引入了基于Web的接入。浏览器成为用户代理，从用户代理到邮件服务器的通信通过HTTP进行。不过，从一个邮件服务器到另一个邮件服务器之间发送和接收邮件仍然采用SMTP。
# 2.4 DNS：因特网的目录服务
因特网上的主机的一种标识方法是用它的主机名（hostname），比如www.facebook.com。然而主机名不提供主机在因特网中的位置信息，而且路由器较难处理，所以主机也可使用IP地址（IP address）标识。
## 2.4.1 DNS提供的服务
==域名系统（Domain Name System，DNS）==的主要任务：能进行主机名到IP地址转换的目录服务。
DNS是：
	- 1. 一个由分层的==DNS服务器（DNS server）==实现的分布式数据库；
	- 2. 一个使得主机能够查询分布式数据库的应用层协议。
- DNS服务器通常是运行==BIND（Berkeley Internet Name Domain）==软件的UNIX机器。
- DNS协议运行在UDP之上，使用53号端口。
- DNS属于客户-服务器模式。
- DNS通常由其他应用层协议使用，包括HTTP、SMTP、FTP，把用户提供的主机名解析为IP地址。例如，当一个浏览器请求一个页面时，发生：
	- 这台用户主机上运行着DNS应用的客户端
	- 浏览器从URL中抽取主机名，把主机名传给DNS应用客户端。
	- DNS客户端向DNS服务器发送一个包含主机名的请求
	- DNS客户端收到回答报文，报文该主机名的对应IP地址。
	- 浏览器向该IP地址80端口HTTP服务器进程发起TCP连接。
- DNS会带来额外时延，有时还很大。但是通常IP地址就缓存在一个附近的DNS服务器里，来减少时延。
- DNS还提供一些重要服务：
	- ==主机别名（host aliasing）==，有的主机有复杂的==规范主机名（canonical hostname）==，一个主机还能拥有多个别名。应用程序可以调用DNS来获得主机别名对应的规范主机名和IP地址。
	- ==邮件服务器别名（mail server aliasing）== ，邮件服务器的主机名可能很复杂，此时会用到好记忆的别名。类似上一个服务。
	- ==负载分配（load distribution）== 。一个站点可能被分布在多个服务器上来分担负荷，所以一个IP地址的集合因此与同一个规范主机名联系，DNS数据库存储着这些IP地址集合，用户用映射到某个IP集合的主机名发出一个DNS请求时，服务器用整个IP集合响应，在每次回答时，用的地址依次循环。这样负载就被循环着分配在每个Web服务器主机上。同样的，也能用在邮件服务器上。
## 2.4.2 DNS工作机理概述
讨论集中在主机名到IP地址转换服务方面。
假设因特网只使用一个DNS服务器，这种集中式设计会面临的问题如下：
- 单点故障（a single point of failure）：如果该服务器崩溃，整个因特网瘫痪。
- 通信容量（traffic volume）：单个DNS服务器要处理来自上亿主机的所有DNS查询。
- 远距离集中式数据库（distant centralized database）：对于距离该服务器较远的主机，查询会面临严重的时延。
- 维护（maintenance）：中央数据库庞大，而且要为每个新添加的主机频繁更新。
这样在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采取分布式设计方案。而且DNS是一个在因特网上实现==分布式数据库==的精彩范例。
### 1. 分布式、层次数据库
- DNS使用大量DNS服务器，分层组织，分布在全世界范围。没有一台DNS服务器拥有因特网上所有主机的映射。
- 大致有三种类型DNS服务器：根服务器、顶级域（Top-Level Domain，TLD）DNS服务器和权威DNS服务器。如下层次组织：![[Pasted image 20230930145021.png]] 假定一个DNS客户要查询主机名www.amazon.com的IP地址，这些DNS服务器以如下方式交互：
- 首先客户端与某个根服务器联系，这个根服务器返回顶级域名com的TLD服务器的IP地址。客户端再与某个TLD服务器联系，这个服务器再返回amazon.com权威服务器的IP地址，最后该客户与amazon.com权威服务器之一联系，这个服务器再返回主机名www.amazon.com的IP地址。
	- ==根DNS服务器==：有400多个根DNS服务器遍及全世界，由13个不同组织管理，提供TLD服务器的IP地址。
	- ==顶级域DNS服务器==：对每个顶级域和所有国家的顶级域都有TLD服务器或服务器集群，由公司或者政府授权机构等维护。TLD服务器提供了权威DNS服务器的IP地址。有时TLD服务器只知道中间的某个DNS服务器，通过某个中间DNS服务器才能知道想要的权威DNS服务器IP。
	- ==权威DNS服务器==：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将主机的名字映射为IP地址。组织的权威DNS服务器收藏了这些DNS记录。组织机构能自己实现自己的权威DNS服务器来保存这些记录，还可以花钱把记录存在服务提供商的权威DNS服务器里。
	- 另外，还有==本地DNS服务器（local DNS server，LDNS）==。每个ISP都有一台本地DNS服务器（页脚默认名字服务器）。当主机和某个ISP连接时，ISP提供一台主机的IP地址。一台主机可以有多台其本地DNS服务器的IP地址（通常通过DHCP）。主机发出DNS请求时，请求先被发往本地DNS服务器，然后转发到DNS服务器层次结构里。后续的多次接收IP、发送请求都直接与本地DNS服务器相关，直到最后获得所请求的主机名的IP地址再发回给最初发送DNS请求的主机。
- ==递归查询（recursive query）==：以自己的名义请求。
- ==迭代查询（iterative query）==：所有回答直接返回给请求者。
- 常用查询模式：![[Pasted image 20230930160137.png]] 包含了一次递归查询（1和8）和三个迭代查询。从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。这是最通常的模式。 
 而下面这种：![[Pasted image 20230930160236.png]] 包含的所有查询都是递归的。
### 2. DNS缓存
DNS缓存（DNS caching）：DNS广泛使用缓存技术。当某个DNS服务器（比如本地DNS服务器）接收一个DNS回答时，它能缓存回答里的任何信息在本地存储器里。缓存可在一段时间后丢弃。
## 2.4.3 DNS记录和报文
所有DNS服务器存储了==资源记录（Resource Record，RR）==，RR提供了主机名到IP地址的映射。每个DNS回答报文都提供了至少一条资源记录。
- 资源记录是一个包含了下列字段的4元组：(Name, Value, Type, TTL)
	- TTL：缓存保留的时间。
	- Name 和 Value 取决于Type：
		- Type = A：Name是主机名，Value是主机名对应的IP。
		- Type = NS：Name是个域，Value是权威DNS服务器的主机名。这个权威DNS服务器知道如何获得该域中那个想要的主机IP。
		- Type = CNAME：Value是别名为Name的主机对应的规范主机名。
		- Type = MX：Value是别名为Name的邮件服务器对应的规范主机名。
		- 一个公司的邮件服务器和其他服务器（比如Web服务器）可以用相同的别名。
### 1. DNS报文
- DNS只有查询和回答两种报文，而且格式相同。![[Pasted image 20230930161905.png]] 前12字节是首部，标识符是一个16比特的数字，只用来标志这个查询，并会被复制在回答报文里，来让请求报文和回答报文能匹配。标志字段有若干个标志，包括报文类型（回答或查询）、权威服务器标志、希望递归标志，递归可用标志，等等。首部有四个跟数字有关的字段，指出首部之后的四类数据区域出现的数量。
- 问题区域包含正在进行的查询的信息，包含
	- 名字字段，包含正在被查询的主机名字
	- 类型字段，指出有关该名字的正被查询的问题类型，比如A或者MX
	- 在来自DNS服务器的回答中，回答区域包含了对最初请求的名字的资源记录。之所以会有多个RR，是因为每个主机名能够有多个IP地址（上面讲过）。
	- 权威区域包含了其他权威服务器的记录。
	- 附加区域包含了其他有帮助的记录。比如，如果一个MX请求的回答报文的回答区域包含了一条RR，提供了邮件服务器的规范主机名，这个附加区域就会包含一个类型A记录，提供了用于该邮件服务器的规范主机名的IP地址。
-可用nslookup程序来直接向某些DNS服务器发送DNS查询报文。
### 2. 在DNS数据库中插入记录
上面讲的是查询，现在讲的是在DNS数据库中的数据是怎么进入的。
- 假如你刚创建一个公司
	- 首先，你会在登记注册机构（registrar）注册域名。注册登记机构是一个商业实体，负责验证域名的唯一性，并将新域名输入DNS数据库。1999年前，只有唯一的注册登记机构，是Network Solution。但是现在，因特网名字和地址分配机构（Internet Corporation for Assigned Names and Numbers，ICANN）向各种注册登记机构授权。
	- 然后，你要向注册登记机构提供基本和辅助权威DNS服务器的名字和IP地址。对每个权威DNS服务器，注册登记机构都会把一个NS和一个A的记录输入对应TLD服务器。对于要用的服务器，比如Web服务器，要有类型A的RR，邮件服务器，要有MX的RR被输入到权威DNS服务器里。
	- 以前，这些输入是静态配置的的。现在可以通过DNS报文对数据库里的内容进行动态添加或者删除。
- 对DNS知识的串联例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=109&selection=543,0,770,0|计算机网络：自顶向下方法（原书第七版）, page 109]] 
- 对DNS安全性的概览：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=110&selection=9,0,313,1|计算机网络：自顶向下方法（原书第七版）, page 110]] 其中，本地服务器为降低DDoS攻击的危害性起到重要作用。
# 2.5 P2P文件分发
本章目前为止讨论的都是客户-服务器体系结构的应用，现在研究P2P应用。
- 考虑某个组织要向现有的用户的操作系统推送一个软件补丁，或者一个MP3音乐文件，或者一个MPEG视频文件，在客户-服务器体系结构中，服务器必须向每个用户都发一个该文件的副本，承受极大负荷和带宽。在P2P中，每个对等方能向任何其他对等方重新分发已经收到的文件的任何部分，从而协助这个服务器。2016年为止，最流行的P2P文件分发协议是BitTorrent。现在有很多符合这个协议的客户端，就像浏览器之于HTTP一样。
## 2.5.1. P2P体系结构的扩展性
- ==分发时间（distribution time）== 是所有N个对等方得到该文件的副本需要的时间。
- 一个假设中的例子：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=111&selection=272,0,288,8|计算机网络：自顶向下方法（原书第七版）, page 111]] 
- P2P体系结构的应用程序是自拓展的，因为对等方除了是比特的消费者，还是它们的重新分发者。
## 2.5.2 BitTorrent
BitTorrent有一些术语。
- ==洪流（torrent）==：参与一个特定文件分发的所有对等方的集合。一个洪流可能在任何时候具有几百或几千个对等方。
- ==块（chunk）==：在一个洪流中的对等方彼此下载等长度的文件块，其中的“块”。典型的块长是256KB。一个对等方首次加入洪流时没有块，随时间推移积累块，下载块时也向对等方上载块。
- ==追踪器（tracker）==：每个洪流具有一个基础设施节点。一个对等方加入洪流时会向追踪器注册自己，并周期性告诉追踪器它还在洪流里。
- 现在，假设一个人（Tom）接入洪流：
	- 追踪器随机从对等方的集合里选择一个子集，把子集里对等方的IP地址发给Tom。
	- Tom尝试与这些IP地址对应的对等方创建TCP连接。（这些对等方可以随时间离开，其他新的对等方又可能会尝试和这个人建立TCP连接，因此每个对等方的临近对等方数量会随时间波动。）
	- 每个对等方有Tom想要的文件的块的子集，不同对等方会有不同的子集。Tom会经过TCP周期性地询问邻近对等方具有的块的列表，并根据列表对尚未拥有的块通过TCP发出请求。
		- 此时有两个重要的事情：首先，Tom从邻近对等方请求哪些块？其次，Tom向哪些向自己请求块的邻近对等方发送块？
			- 对第一件事情，Tom用==最稀缺优先（rarest first）==技术。思路是，向邻居请求在邻居中副本数量最少的块。这样，稀缺的块会更早重新分发，这样会均衡每个块在洪流中的副本数量。
			- 对第二件事情，使用一种对换算法。思路是，向当前能够以最高速率向Tom提供数据的邻居（最高的几个）给出优先权。这几个对等方被称为疏通（unchoked）。除此之外，每一小段时间后，Tom会另外随机选一个新的邻居发送这个邻居想要的块，这样的话，Tom可能成为这个邻居的最高速率提供者之一，这个邻居就会持续向Tom发送数据，这个邻居也可能成为Tom的最高速率发送者之一。这样的效果是，对等方能够以趋向于找到彼此的协调的速率上载。
				- 除了这几个Tom发送块的邻近对等方，其他相邻对等方都被阻塞，即不能从Tom收到任何块。
		- 刚提到的交换的激励机制被称为“一报还一报”（tit-for-tat）。这是至关重要的一个设计。
		- 此外，BitTorrent还有许多机制没提到，包括片（小块）、流水线、随机优先选择、残局模型、反怠慢。
- 简要提到另一种P2P应用：==分布式散列表（DHT）==。这是一种简单的数据库，数据库记录分布在一个P2P系统的多个对等方上。DHT也在BitTorrent中实现。
# 2.6 视频流和内容分发网
## 2.6.1 因特网视频
- 流式存储视频应用中，基础的媒体是预先录制的视频，比如电影、用户录制的视频。这些预先录制好的视频放在服务器上，用户发送请求来观看这些视频。
- 视频可以被压缩，现在的压缩算法能够把一个视频压缩成任何比特率。比特率越高，视频质量越好。视频的比特率在网络的观点来看是高比特率。
- 流式视频最重要的性能度量是平均端到端吞吐量。
## 2.6.2 HTTP 流和 DASH
HTTP流的过程：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=116&selection=57,0,149,1|计算机网络：自顶向下方法（原书第七版）, page 116]] 。总体上概括为：TCP连接，对视频文件URL的HTTP GET请求，用户端把字节缓存，缓存到一定预设量就开始播放视频。播放时，应用从缓存里周期性抓取帧，解压后展现在屏幕上。
- 缺陷：所有客户接收到相同编码的视频，但是客户可用的带宽有很大不同。这可能导致低带宽的用户卡顿。
- ==经HTTP的动态适应性流（Dynamic Adaptive Streaming overHTTP， DASH）==：视频被编码为几个不同的版本，每个版本有不同的比特率。客户动态地请求长度为几秒的视频段数据块，当可用带宽量很高时，客户自动选择来自高比特率的块。反之选择低比特率的块（还跟缓存量有关）。客户用HTTP GET请求报文一次选择一个不同的块。
	- 用DASH之后，每个视频的版本储存在HTTP服务器里，每个版本有不同的URL，HTTP服务器也有一个==告示文件（manifest file）==，为每个版本标明一个URL和比特率。
## 2.6.3 内容分发网
用客户-服务器体系架构，视频公司的数据中心面临巨大带宽压力和远端请求的时延等等问题。
- ==内容分发网（Content Distribution Network，CDN）== ：CDN管理分布在多个地理位置上的服务器，并且在服务器里存储文件的副本，并且试图将每个用户请求定向到一个提供最好的用户体验的CDN位置。
- CDN可以用专用CDN（private CDN），即内容提供商自己所有。还可以是第三方CDN（third-party CND），帮多个内容提供商分发内容。
- 谷歌的网络基础设施案例：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=117&selection=204,0,433,1|计算机网络：自顶向下方法（原书第七版）, page 117]] 
- CDN采用两个不同的服务器安放原则：
	- 深入。在全球ISP各种地方部署服务器集群。
	- 邀请做客。在少量关键位置部署大集群，比如因特网交换点（IXP）邀请到ISP做客。
- CDN可能在不同的国家放不同的流行内容。一个用户请求一个未存储的内容，就从中心仓库或者其他集群请求内容，发给用户，同时生成副本在自己的储存里。储存要满的时候把不经常请求的视频删除。
### 1. CDN操作
- CDN的操作里，重点之一是截获和重定向。大多数CDN用DNS来截获和重定向请求。
- 当内容提供商使用CDN时，在网络请求走到权威服务器时，权威服务器识别出主机名的某个标志字符串，比如video.netcinema.com中的video，就向本地服务器返回CDN域的一个主机名，而不是IP。此时，本地服务器就被重定向，开启第二个请求，向着这个新的主机名。与这个新主机名的IP建立TCP后执行视频HTTP GET请求。
### 2. 集群选择策略
所有CDN部署的核心是集群选择策略（cluster selection strategy）
- 一种简单策略是指派客户到地理上最邻近（geographically closest）的集群。但地理最邻近可能不是网络路径长度最近的集群。还有，有的客户可能用很远的LDNS。
- 基于当前流量条件来为客户决定最好的集群，CDN对集群和客户之间的时延和丢包性能执行周期性的==实时测量（real-time measurement）==。CND让每个集群向全世界所有LDNS发送探测分组（ping报文或者DNS请求）。缺点是许多LDNS被配置未不会响应这些探测。
## 2.6.4 学习案例：Netflix、YouTube和“看看”
见：[[计算机网络：自顶向下方法（原书第七版）.pdf#page=119&selection=527,0,537,5|计算机网络：自顶向下方法（原书第七版）, page 119]] 
# 2.7 套接字编程：生成网络应用
- 网络应用程序有两类，一类是由协议标准中定义的操作实现，另一类是专用的网络应用程序，应用层协议没有公开发布。
- 典型的网络应用是由一对程序（客户程序和服务器程序）组成，位于不同的端系统中。
- 接下来，用Python3实现简单的UDP和TCP应用程序。自己实现的应用程序需要避开常用公开协议的端口号。
## 2.7.1 UDP 套接字编程
- 生成套接字时，需要目的地址，包括目的主机的IP地址和端口号。此外还需要发送方的源地址，但是这个地址往往由底层操作系统自动完成。
- 测试程序：![[Pasted image 20231002213423.png]]
- 对应代码：
	- 客户端：
		- [[计算机网络：自顶向下方法（原书第七版）.pdf#page=125&selection=54,0,60,2|计算机网络：自顶向下方法（原书第七版）, page 125]] 
		- ![[Pasted image 20231002215333.png]] 
		- ![[UDPClient.py]] 
	- 服务器端：
		- [[计算机网络：自顶向下方法（原书第七版）.pdf#page=126&selection=194,0,200,2|计算机网络：自顶向下方法（原书第七版）, page 126]] 
		- ![[Pasted image 20231002221311.png]]
		- ![[UDPServer.py]] 
## 2.7.2 TCP套接字编程
首先，服务器持续运行一个进程，这个套接字欢迎来自任意客户，服务于初始接触。然后，客户端发起握手，进行三次握手，期间敲门。服务器听到敲门时，生成一扇新门（套接字），专门服务一个客户。这个新的套接字叫连接套接字（connectionSocket）。
- 测试程序：![[Pasted image 20231002224246.png]] 
- 对应代码：
	- 客户端：
		- [[计算机网络：自顶向下方法（原书第七版）.pdf#page=129&selection=0,2,4,2|计算机网络：自顶向下方法（原书第七版）, page 129]] 
		- ![[Pasted image 20231002225553.png]] 
		-  ![[TCPClient.py]]
	- 服务器端：
		- [[计算机网络：自顶向下方法（原书第七版）.pdf#page=129&selection=504,0,508,2|计算机网络：自顶向下方法（原书第七版）, page 129]] 
		- ![[Pasted image 20231002230544.png]] 
		- ![[TCPServer.py]]
# 2.8 小结
[[计算机网络：自顶向下方法（原书第七版）.pdf#page=130&selection=386,0,388,2|计算机网络：自顶向下方法（原书第七版）, page 130]] 